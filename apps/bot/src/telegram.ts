import TelegramBot from "node-telegram-bot-api";
import { AdaptiveAnalyzer, MarketCondition, AdaptiveCriteria } from './adaptiveAnalyzer.js';

const adaptiveAnalyzer = new AdaptiveAnalyzer();

export function makeBot(token: string) {
  const bot = new TelegramBot(token, { 
    polling: {
      interval: 1000,
      autoStart: true,
      params: {
        timeout: 10
      }
    }
  });
  
  // Handle polling errors to prevent conflicts
  bot.on('polling_error', (error) => {
    console.error('‚ùå Telegram polling error:', error.message);
    if (error.message.includes('409 Conflict')) {
      console.log('‚ö†Ô∏è Another bot instance detected. Stopping polling...');
      bot.stopPolling();
    }
  });
  
  return bot;
}

export function setupBotCommands(bot: TelegramBot) {
  // Main menu keyboard with enhanced styling
  const mainMenu = {
    reply_markup: {
      keyboard: [
        [ { text: "üß† AI Buy Signals" }, { text: "üìä Market Analysis" } ],
        [ { text: "üî• Top Tokens" }, { text: "üìà Live Metas" } ],
        [ { text: "‚öôÔ∏è AI Settings" }, { text: "üåê Website" } ],
        [ { text: "‚ÑπÔ∏è About MetaPulse" } ]
      ],
      resize_keyboard: true,
      one_time_keyboard: false
    }
  };

  // Handle /start command with enhanced welcome
  bot.onText(/\/start/, (msg: any) => {
    const chatId = msg.chat.id;
    const welcomeText = `ü§ñ **Welcome to MetaPulse AI Bot** ‚Äî $PULSEAI

üß† **Feel the pulse before the market does.**

üöÄ **NEW AI-POWERED FEATURES:**
‚Ä¢ üß† Adaptive Buy Signals - AI learns and adjusts criteria
‚Ä¢ üìä Real-time Market Analysis - Smart trend detection  
‚Ä¢ üéØ Risk Assessment - Conservative/Moderate/Aggressive
‚Ä¢ üìà Performance Tracking - AI learns from success rates

üíé **What makes us different:**
‚Ä¢ Self-learning algorithms that adapt to market conditions
‚Ä¢ Multi-source data analysis (DexScreener, CoinGecko)
‚Ä¢ Professional risk management strategies
‚Ä¢ Real-time sentiment analysis (coming soon)

üåê **Website:** https://www.metapulse.tech
üì± **Use the menu below to get started!**

‚ö†Ô∏è *Always DYOR. Not financial advice.*`;

    const welcomeKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üß† Try AI Signals", callback_data: "refresh_scan" },
            { text: "üìä Market Analysis", callback_data: "market_analysis" }
          ],
          [
            { text: "üåê Visit Website", url: "https://www.metapulse.tech" }
          ]
        ]
      }
    };

    bot.sendMessage(chatId, welcomeText, { 
      parse_mode: 'Markdown',
      ...welcomeKeyboard
    });
  });

  // Handle menu button clicks
  bot.onText(/üìä Live Metas/, (msg: any) => {
    const chatId = msg.chat.id;
    // Get real data from the bot's memory
    const scoresArray = (globalThis as any).SCORES?.values() || [];
    const metas = (Array.from(scoresArray) as any[])
      .reduce((acc: any, score: any) => {
        const existing = acc.find((m: any) => m.label === score.label);
        if (existing) {
          existing.count++;
          existing.totalScore += score.total;
        } else {
          acc.push({ label: score.label, count: 1, totalScore: score.total });
        }
        return acc;
      }, [])
      .map((m: any) => ({ ...m, avgScore: Math.round(m.totalScore / m.count) }))
      .sort((a: any, b: any) => b.avgScore - a.avgScore)
      .slice(0, 5);

    if (metas.length === 0) {
      bot.sendMessage(chatId, "üîç Scanning for live metas...\n\nNo data available yet. The bot is collecting market data. Check back in a few minutes!", mainMenu);
    } else {
      const metaText = metas.map((m: any, i: number) => 
        `${i + 1}. ${m.label} - ${m.count} tokens, avg score: ${m.avgScore}`
      ).join('\n');
      bot.sendMessage(chatId, `üî• Live Metas Detected:\n\n${metaText}\n\n*AI Analysis Active*`, { 
        parse_mode: 'Markdown',
        reply_markup: mainMenu.reply_markup 
      });
    }
  });

  bot.onText(/üî• Top Tokens/, (msg: any) => {
    const chatId = msg.chat.id;
    // Get real token data
    const entriesArray = (globalThis as any).SCORES?.entries() || [];
    const tokens = (Array.from(entriesArray) as any[])
      .map((entry: any) => {
        const [mint, score] = entry as [string, any];
        const info = (globalThis as any).TOK_INFO?.get(mint) || {};
        return { mint, name: info.name, symbol: info.symbol, totalScore: score.total, label: score.label };
      })
      .sort((a: any, b: any) => b.totalScore - a.totalScore)
      .slice(0, 5);

    if (tokens.length === 0) {
      bot.sendMessage(chatId, "üöÄ Loading top performing tokens...\n\nNo tokens analyzed yet. The bot is scanning the market for new tokens. Check back in a few minutes!", mainMenu);
    } else {
      const tokenText = tokens.map((t: any, i: number) => 
        `${i + 1}. ${t.name || 'Unknown'} ${t.symbol ? `(${t.symbol})` : ''} - Score: ${t.totalScore}`
      ).join('\n');
      bot.sendMessage(chatId, `üöÄ Top Performing Tokens:\n\n${tokenText}\n\n*Real-time AI Analysis*`, { 
        parse_mode: 'Markdown',
        reply_markup: mainMenu.reply_markup 
      });
    }
  });

  bot.onText(/üìà Market Stats/, (msg: any) => {
    const chatId = msg.chat.id;
    const totalTokens = (globalThis as any).SCORES?.size || 0;
    const totalTrades = (globalThis as any).ROLLUPS?.allMints().length || 0;
    const valuesArray = (globalThis as any).SCORES?.values() || [];
    const metas = new Set((Array.from(valuesArray) as any[]).map((s: any) => s.label)).size;
    
    bot.sendMessage(chatId, `üìä Market Statistics\n\n‚Ä¢ Total tokens analyzed: ${totalTokens}\n‚Ä¢ Active metas: ${metas}\n‚Ä¢ Total trades: ${totalTrades}\n‚Ä¢ AI confidence: 95%\n‚Ä¢ Last update: Just now`, mainMenu);
  });

  bot.onText(/‚öôÔ∏è Settings/, (msg: any) => {
    const chatId = msg.chat.id;
    const settingsText = `‚öôÔ∏è Bot Settings

üîî Notifications: Enabled
üìä Update frequency: Hourly
ü§ñ AI Model: Gemini 2.0 Flash
üìà Min score threshold: 50

Use /help for more commands.`;
    bot.sendMessage(chatId, settingsText, mainMenu);
  });

  bot.onText(/‚ÑπÔ∏è About/, (msg: any) => {
    const chatId = msg.chat.id;
    const aboutText = `‚ÑπÔ∏è **About MetaPulse AI Bot**

ü§ñ **Version:** 1.0.0
üîó **Website:** https://www.metapulse.tech
üì± **Telegram:** @MetaPulseAIBot
üê¶ **Twitter:** @METAPULSaibot

MetaPulse AI Bot is an AI-powered market intelligence system built on Solana. It detects trending metas and token narratives in real-time using advanced AI analysis.

**Features:**
‚úÖ Real-time token scanning
‚úÖ AI-powered categorization
‚úÖ Live market feeds
‚úÖ Meta trend detection

**Roadmap:**
Phase 1: ‚úÖ AI Market Scanner
Phase 2: üöß Advanced Trading Signals
Phase 3: üöß Multi-Chain Expansion
Phase 4: üöß Revenue Dashboard

üí∞ **Token:** $PULSEAI
*Feel the pulse before the market does.*`;
    
    bot.sendMessage(chatId, aboutText, { 
      parse_mode: 'Markdown',
      reply_markup: mainMenu.reply_markup 
    });
  });

  bot.onText(/üåê Website/, (msg: any) => {
    const chatId = msg.chat.id;
    const websiteText = `üåê **MetaPulse AI - Links**

üè† Website: https://www.metapulse.tech

üìä **Live Data:**
‚Ä¢ Live Feed: https://www.metapulse.tech/feed
‚Ä¢ Token Scanner: https://www.metapulse.tech/tokens  
‚Ä¢ Meta Analysis: https://www.metapulse.tech/metas

üíé **Presale:**
‚Ä¢ Join Presale: https://www.metapulse.tech/presale

üê¶ **Social Media:**
‚Ä¢ Twitter/ùïè: https://x.com/METAPULSaibot
‚Ä¢ Telegram Bot: @MetaPulseAIBot

üí∞ **Token:** $PULSEAI
*Feel the pulse before the market does.*`;

    bot.sendMessage(chatId, websiteText, { 
      parse_mode: 'Markdown',
      reply_markup: mainMenu.reply_markup 
    });
  });

  // Handle help command
  bot.onText(/\/help/, (msg: any) => {
    const chatId = msg.chat.id;
    const helpText = `üÜò Help & Commands

/start - Show main menu
/help - Show this help message
/status - Bot status and uptime
/website - Get website link
/buysignals - Get filtered buy opportunities

üìä Use the menu buttons to navigate:
‚Ä¢ Live Metas - View trending categories
‚Ä¢ Top Tokens - See best performing tokens
‚Ä¢ Buy Signals - Top 10 filtered tokens (hourly auto-updates)
‚Ä¢ Market Stats - Current market overview
‚Ä¢ Settings - Configure your preferences
‚Ä¢ About - Learn more about MetaPulse
‚Ä¢ Website - Access web interface

üíé Buy Signals Filters:
‚Ä¢ Liquidity ‚â• $80,000
‚Ä¢ Market Cap: $1M - $80M
‚Ä¢ Pair Age ‚â§ 60 hours
‚Ä¢ Transactions ‚â• 3,000
‚Ä¢ Sorted by Volume`;
    bot.sendMessage(chatId, helpText, mainMenu);
  });

  // Handle status command
  bot.onText(/\/status/, (msg: any) => {
    const chatId = msg.chat.id;
    const statusText = `üü¢ Bot Status: Online
‚è∞ Uptime: Active
üîó Market Data: Connected
ü§ñ AI: Gemini 2.0 Flash
üìä Tokens tracked: 0
üîÑ Last update: Just started`;
    bot.sendMessage(chatId, statusText, mainMenu);
  });

  // Handle website command
  bot.onText(/\/website/, (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üåê MetaPulse Website\n\nMain site: https://www.metapulse.tech\nLive metas: https://www.metapulse.tech/metas", mainMenu);
  });

  // Update command handlers to match new menu
  bot.onText(/üß† AI Buy Signals/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üß† AI analyzing market conditions...", mainMenu);
    await sendBuySignals(bot, chatId);
  });

  bot.onText(/üìä Market Analysis/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üìä Generating AI market analysis...", mainMenu);
    await sendMarketAnalysis(bot, chatId);
  });

  bot.onText(/‚öôÔ∏è AI Settings/, async (msg: any) => {
    const chatId = msg.chat.id;
    await sendBotSettings(bot, chatId);
  });

  bot.onText(/‚ÑπÔ∏è About MetaPulse/, async (msg: any) => {
    const chatId = msg.chat.id;
    const aboutText = `‚ÑπÔ∏è **About MetaPulse AI** ‚Äî $PULSEAI

üß† **Mission:**
Democratizing crypto intelligence through AI-powered market analysis.

üéØ **Core Technology:**
‚Ä¢ Adaptive Learning Algorithms
‚Ä¢ Multi-source Data Aggregation  
‚Ä¢ Real-time Risk Assessment
‚Ä¢ Predictive Market Analysis

üìä **Data Sources:**
‚Ä¢ DexScreener (DEX data)
‚Ä¢ CoinGecko (Market metrics)
‚Ä¢ Social Sentiment APIs (coming)
‚Ä¢ On-chain Analytics (planned)

üöÄ **Roadmap:**
‚Ä¢ ‚úÖ Phase 1: AI Buy Signals
‚Ä¢ üîÑ Phase 2: Sentiment Analysis
‚Ä¢ üìã Phase 3: Portfolio Management
‚Ä¢ üìã Phase 4: Advanced Trading Tools

üë• **Team:**
Experienced developers and traders building the future of crypto intelligence.

üåê **Links:**
‚Ä¢ Website: https://www.metapulse.tech
‚Ä¢ Telegram: @MetaPulseAI

‚ö†Ô∏è **Disclaimer:** Educational tool only. Not financial advice.`;

    const aboutKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üß† Try AI Features", callback_data: "refresh_scan" },
            { text: "üåê Website", url: "https://www.metapulse.tech" }
          ]
        ]
      }
    };

    bot.sendMessage(chatId, aboutText, {
      parse_mode: 'Markdown',
      ...aboutKeyboard
    });
  });
  // Keep legacy commands for backward compatibility
  bot.onText(/\/buysignals/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üß† AI analyzing market conditions...", mainMenu);
    await sendBuySignals(bot, chatId);
  });

  bot.onText(/üíé Buy Signals/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üß† AI scanning with adaptive criteria...", mainMenu);
    await sendBuySignals(bot, chatId);
  });

  bot.onText(/üìà Market Stats/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üìä Generating AI market analysis...", mainMenu);
    await sendMarketAnalysis(bot, chatId);
  });

  bot.onText(/üìà Live Metas/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üìà Live Metas feature coming soon!\n\nFor now, try our AI Buy Signals.", mainMenu);
  });

  bot.onText(/üî• Top Tokens/, async (msg: any) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, "üî• Top Tokens feature coming soon!\n\nFor now, try our AI Buy Signals for the best opportunities.", mainMenu);
  });

  // Handle callback queries
  bot.on('callback_query', async (callbackQuery: any) => {
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;
    
    // Answer the callback query to remove loading state
    await bot.answerCallbackQuery(callbackQuery.id);
    
    switch (data) {
      case 'refresh_scan':
        await bot.sendMessage(chatId, "üîÑ Refreshing AI analysis...", mainMenu);
        await sendBuySignals(bot, chatId);
        break;
        
      case 'market_analysis':
        await bot.sendMessage(chatId, "üìä Generating detailed market analysis...", mainMenu);
        await sendMarketAnalysis(bot, chatId);
        break;
        
      case 'adjust_criteria':
        await bot.sendMessage(chatId, 
          "‚öôÔ∏è **Adaptive Criteria Settings**\n\n" +
          "The AI automatically adjusts criteria based on:\n" +
          "‚Ä¢ Market volatility conditions\n" +
          "‚Ä¢ Current trend analysis\n" +
          "‚Ä¢ Volume patterns\n" +
          "‚Ä¢ Social sentiment\n" +
          "‚Ä¢ Historical performance\n\n" +
          "ü§ñ No manual adjustment needed - AI handles optimization!",
          { parse_mode: 'Markdown', ...mainMenu }
        );
        break;
        
      case 'bot_settings':
        await sendBotSettings(bot, chatId);
        break;
        
      default:
        await bot.sendMessage(chatId, "‚ùì Unknown command. Please use the menu.", mainMenu);
    }
  });

  // Add new market analysis function
  async function sendMarketAnalysis(bot: TelegramBot, chatId: string | number) {
    try {
      const marketCondition = await adaptiveAnalyzer.analyzeMarketConditions();
      const adaptiveCriteria = adaptiveAnalyzer.generateAdaptiveCriteria(marketCondition);
      const insights = adaptiveAnalyzer.getAdaptiveInsights(marketCondition, adaptiveCriteria);
      
      const analysisText = [
        "üß† **COMPREHENSIVE MARKET ANALYSIS**",
        "",
        insights,
        "",
        "üìà **Market Recommendations:**",
        marketCondition.trend === 'bullish' ? "‚Ä¢ üü¢ Favorable conditions for new positions" : 
        marketCondition.trend === 'bearish' ? "‚Ä¢ üî¥ Exercise caution, consider defensive positions" :
        "‚Ä¢ üü° Neutral market, wait for clearer signals",
        "",
        marketCondition.volatility === 'high' ? "‚Ä¢ ‚ö° High volatility - Use smaller position sizes" :
        marketCondition.volatility === 'low' ? "‚Ä¢ üò¥ Low volatility - Consider larger positions" :
        "‚Ä¢ ‚öñÔ∏è Moderate volatility - Standard position sizing",
        "",
        "üéØ **AI Strategy:** " + adaptiveCriteria.riskLevel.toUpperCase(),
        "",
        "‚è∞ Analysis updated in real-time",
        "ü§ñ Powered by MetaPulse AI"
      ].join("\n");
      
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: "üîÑ Refresh Analysis", callback_data: "market_analysis" },
              { text: "üíé Buy Signals", callback_data: "refresh_scan" }
            ]
          ]
        }
      };
      
      await bot.sendMessage(chatId, analysisText, {
        parse_mode: 'Markdown',
        ...keyboard
      });
      
    } catch (error) {
      console.error('‚ùå Error in market analysis:', error);
      await bot.sendMessage(chatId, 
        "‚ùå Unable to generate market analysis. Please try again.",
        mainMenu
      );
    }
  }

  // Add bot settings function
  async function sendBotSettings(bot: TelegramBot, chatId: string | number) {
    const settingsText = [
      "‚öôÔ∏è **BOT SETTINGS & INFO**",
      "",
      "ü§ñ **AI Features:**",
      "‚Ä¢ ‚úÖ Adaptive Buy Signals",
      "‚Ä¢ ‚úÖ Market Condition Analysis", 
      "‚Ä¢ ‚úÖ Performance Learning",
      "‚Ä¢ ‚úÖ Risk Assessment",
      "",
      "üìä **Data Sources:**",
      "‚Ä¢ DexScreener API (Real-time)",
      "‚Ä¢ CoinGecko API (Market data)",
      "‚Ä¢ Social Sentiment (Coming soon)",
      "",
      "‚è∞ **Update Frequency:**",
      "‚Ä¢ Buy Signals: Every hour",
      "‚Ä¢ Market Analysis: Real-time",
      "‚Ä¢ Performance Tracking: 24h cycles",
      "",
      "üîî **Notifications:**",
      "‚Ä¢ Currently: Manual refresh",
      "‚Ä¢ Coming: Smart alerts",
      "",
      "üåê **Website:** https://www.metapulse.tech"
    ].join("\n");
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üíé Buy Signals", callback_data: "refresh_scan" },
            { text: "üìä Analysis", callback_data: "market_analysis" }
          ],
          [
            { text: "üåê Website", url: "https://www.metapulse.tech" }
          ]
        ]
      }
    };
    
    await bot.sendMessage(chatId, settingsText, {
      parse_mode: 'Markdown',
      ...keyboard
    });
  }
}

export async function sendDigest(bot: TelegramBot, chatId: string | number, payload: {
  metas: { label: string; count: number; avgScore: number }[];
  tokens: { mint: string; name?: string; symbol?: string; totalScore: number }[];
}) {
  // Format metas with emojis and better styling
  const metaLines = payload.metas.map(m => {
    const emoji = {
      'ai-agents': 'ü§ñ',
      'frogs': 'üê∏', 
      'celeb': '‚≠ê',
      'halloween': 'üéÉ',
      'gaming': 'üéÆ',
      'doge-meme': 'üêï',
      'politics': 'üèõÔ∏è',
      'nsfw': 'üîû',
      'defi': 'üè¶',
      'meme': 'üòÇ',
      'anime': 'üéå',
      'sports': '‚öΩ',
      'music': 'üéµ',
      'art': 'üé®',
      'tech': 'üíª',
      'unknown': '‚ùì'
    }[m.label] || 'üìä';
    
    return `${emoji} **${m.label}** ‚Äî ${m.count} tokens ‚Ä¢ Score: ${Math.round(m.avgScore)}`;
  });

  // Format tokens with better styling and truncate long names
  const tokenLines = payload.tokens.map((t, i) => {
    const name = t.name ? (t.name.length > 20 ? t.name.substring(0, 17) + '...' : t.name) : 'Unknown';
    const symbol = t.symbol ? `(${t.symbol})` : '';
    const score = Math.round(t.totalScore);
    const scoreEmoji = score >= 70 ? 'üî•' : score >= 50 ? 'üìà' : score >= 30 ? 'üìä' : 'üìâ';
    
    return `${i + 1}. ${scoreEmoji} **${name}** ${symbol} ‚Äî Score: ${score}`;
  });

  const text = [
    "üöÄ **MetaPulse AI Bot ‚Äî Hourly Meta Digest**",
    "",
    "üìä **Top Metas:**",
    ...metaLines,
    "",
    "üèÜ **Top Tokens:**",
    ...tokenLines,
    "",
    "üí° *Note: Sniper and Launcher modules are scheduled for Phase 2. This bot is currently free to use.*"
  ].join("\n");

  await bot.sendMessage(chatId, text, { 
    parse_mode: 'Markdown',
    disable_web_page_preview: true 
  });
}

interface BuySignalToken {
  address: string;
  name: string;
  symbol: string;
  price: number;
  volume24h: number;
  liquidity: number;
  marketCap: number;
  pairAge: number;
  transactions24h: number;
  priceChange24h: number;
}

export async function sendBuySignals(bot: TelegramBot, chatId: string | number) {
  try {
    console.log('üß† AI analyzing market conditions...');
    
    // Step 1: Analyze current market conditions using AI
    const marketCondition = await adaptiveAnalyzer.analyzeMarketConditions();
    console.log('üìä Market analysis:', marketCondition);
    
    // Step 2: Generate adaptive criteria based on market conditions
    const adaptiveCriteria = adaptiveAnalyzer.generateAdaptiveCriteria(marketCondition);
    console.log('üéØ Adaptive criteria:', adaptiveCriteria);
    
    // Step 3: Fetch trending Solana tokens from DexScreener
    const response = await fetch('https://api.dexscreener.com/latest/dex/search?q=solana&rankBy=trendingScoreH24&order=desc');
    const data = await response.json();
    
    if (!data.pairs || data.pairs.length === 0) {
      console.log('‚ö†Ô∏è No pairs data available from DexScreener');
      return;
    }

    // Step 4: Filter tokens using adaptive criteria
    const now = Date.now();
    const filteredTokens: BuySignalToken[] = data.pairs
      .filter((pair: any) => {
        // Extract data with better handling of missing transaction data
        const liquidity = parseFloat(pair.liquidity?.usd || 0);
        const marketCap = parseFloat(pair.fdv || pair.marketCap || 0);
        const pairCreatedAt = pair.pairCreatedAt || 0;
        const pairAgeHours = (now - pairCreatedAt) / (1000 * 60 * 60);
        
        // Handle missing transaction data - use volume as proxy for activity
        const transactions24h = (pair.txns?.h24?.buys || 0) + (pair.txns?.h24?.sells || 0);
        const volume24h = parseFloat(pair.volume?.h24 || 0);
        const hasActivity = transactions24h > 0 || volume24h > 1000; // Use volume as activity indicator
        
        const volumeChange = parseFloat(pair.priceChange?.h24 || 0);
        
        // Apply adaptive filters with more lenient transaction requirements
        return (
          liquidity >= adaptiveCriteria.minLiquidity &&
          liquidity <= adaptiveCriteria.maxLiquidity &&
          marketCap >= adaptiveCriteria.minMarketCap &&
          marketCap <= adaptiveCriteria.maxMarketCap &&
          pairAgeHours <= adaptiveCriteria.maxPairAge &&
          (transactions24h >= adaptiveCriteria.minTransactions || hasActivity) && // Allow volume-based activity
          volumeChange >= adaptiveCriteria.minVolumeChange
        );
      })
      .map((pair: any) => ({
        address: pair.baseToken?.address || '',
        name: pair.baseToken?.name || 'Unknown',
        symbol: pair.baseToken?.symbol || '???',
        price: parseFloat(pair.priceUsd || 0),
        volume24h: parseFloat(pair.volume?.h24 || 0),
        liquidity: parseFloat(pair.liquidity?.usd || 0),
        marketCap: parseFloat(pair.fdv || pair.marketCap || 0),
        pairAge: (now - (pair.pairCreatedAt || 0)) / (1000 * 60 * 60),
        transactions24h: (pair.txns?.h24?.buys || 0) + (pair.txns?.h24?.sells || 0),
        priceChange24h: parseFloat(pair.priceChange?.h24 || 0)
      }))
      .sort((a: BuySignalToken, b: BuySignalToken) => b.volume24h - a.volume24h)
      .slice(0, 10);

    // Step 5: Track performance for learning
    await adaptiveAnalyzer.trackTokenPerformance(filteredTokens);

    // Step 6: Generate adaptive insights
    const adaptiveInsights = adaptiveAnalyzer.getAdaptiveInsights(marketCondition, adaptiveCriteria);

    if (filteredTokens.length === 0) {
      console.log('üìä No tokens matching adaptive criteria found');
      
      // Create inline keyboard for interactive options
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: "üîÑ Refresh Scan", callback_data: "refresh_scan" },
              { text: "‚öôÔ∏è Adjust Criteria", callback_data: "adjust_criteria" }
            ],
            [
              { text: "üìä Market Analysis", callback_data: "market_analysis" },
              { text: "üåê View Website", url: "https://www.metapulse.tech" }
            ]
          ]
        }
      };

      await bot.sendMessage(chatId, 
        "üîç **AI-Powered Buy Signals Update**\n\n" +
        "No tokens currently match the adaptive criteria.\n\n" +
        adaptiveInsights + "\n\n" +
        "ü§ñ The AI is continuously learning and adapting...",
        { 
          parse_mode: 'Markdown',
          ...keyboard
        }
      );
      return;
    }

    // Format tokens for message with enhanced styling
    const formatNumber = (num: number) => {
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
      return num.toFixed(2);
    };

    const getRiskEmoji = (token: BuySignalToken, criteria: AdaptiveCriteria) => {
      if (criteria.riskLevel === 'conservative') return 'üõ°Ô∏è';
      if (criteria.riskLevel === 'aggressive') return '‚ö°';
      return '‚öñÔ∏è';
    };

    const tokenLines = filteredTokens.map((token, i) => {
      const priceEmoji = token.priceChange24h >= 20 ? 'üöÄ' : 
                        token.priceChange24h >= 10 ? 'üî•' :
                        token.priceChange24h >= 0 ? 'üìà' : 
                        token.priceChange24h >= -10 ? 'üìâ' : 'üîª';
      const changeSign = token.priceChange24h >= 0 ? '+' : '';
      const riskEmoji = getRiskEmoji(token, adaptiveCriteria);
      
      return [
        `${riskEmoji} **${i + 1}. ${token.symbol}** - ${token.name}`,
        `   ${priceEmoji} $${token.price.toFixed(8)} (${changeSign}${token.priceChange24h.toFixed(2)}%)`,
        `   üí∞ MCap: $${formatNumber(token.marketCap)} | üíß Liq: $${formatNumber(token.liquidity)}`,
        `   üìä Vol: $${formatNumber(token.volume24h)} | üîÑ Txns: ${formatNumber(token.transactions24h)}`,
        `   ‚è∞ Age: ${token.pairAge.toFixed(1)}h | üéØ Risk: ${adaptiveCriteria.riskLevel}`,
        `   üîó \`${token.address}\``,
        ''
      ].join('\n');
    });

    // Create interactive keyboard
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üîÑ Refresh", callback_data: "refresh_scan" },
            { text: "üìä Analysis", callback_data: "market_analysis" }
          ],
          [
            { text: "‚öôÔ∏è Settings", callback_data: "bot_settings" },
            { text: "üåê Website", url: "https://www.metapulse.tech" }
          ]
        ]
      }
    };

    const text = [
      "üß† **AI-POWERED BUY SIGNALS**",
      "",
      adaptiveInsights,
      "",
      "üéØ **Top Opportunities:**",
      "",
      ...tokenLines,
      "‚ö†Ô∏è **Risk Disclaimer:** AI-generated signals. DYOR. Not financial advice.",
      "ü§ñ **MetaPulse AI** - Continuously learning and adapting"
    ].join("\n");

    await bot.sendMessage(chatId, text, { 
      parse_mode: 'Markdown',
      disable_web_page_preview: true,
      ...keyboard
    });
    
    console.log(`‚úÖ AI buy signals sent successfully (${filteredTokens.length} tokens, ${adaptiveCriteria.riskLevel} risk)`);
  } catch (error) {
    console.error('‚ùå Error in AI buy signals:', error);
    
    // Send error message with retry option
    const errorKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üîÑ Retry", callback_data: "refresh_scan" }]
        ]
      }
    };
    
    await bot.sendMessage(chatId, 
      "‚ùå **AI Analysis Error**\n\n" +
      "The AI encountered an issue while analyzing market conditions.\n\n" +
      "Please try again in a moment.",
      { 
        parse_mode: 'Markdown',
        ...errorKeyboard
      }
    );
  }
}